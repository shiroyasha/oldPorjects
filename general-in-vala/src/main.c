/* main.c generated by valac 0.9.8, the Vala compiler
 * generated from main.vala, do not modify */

/* main.vala
 *
 * Copyright (C) 2010  Igor Sarcevic
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *  
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *  
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * Author:
 * 	Igor Sarcevic <igisar@gmail.com>
 */

#include <glib.h>
#include <glib-object.h>
#include <gtk/gtk.h>
#include <stdlib.h>
#include <string.h>


#define TYPE_APPLICATION_WINDOW (application_window_get_type ())
#define APPLICATION_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), TYPE_APPLICATION_WINDOW, ApplicationWindow))
#define APPLICATION_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), TYPE_APPLICATION_WINDOW, ApplicationWindowClass))
#define IS_APPLICATION_WINDOW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), TYPE_APPLICATION_WINDOW))
#define IS_APPLICATION_WINDOW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), TYPE_APPLICATION_WINDOW))
#define APPLICATION_WINDOW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), TYPE_APPLICATION_WINDOW, ApplicationWindowClass))

typedef struct _ApplicationWindow ApplicationWindow;
typedef struct _ApplicationWindowClass ApplicationWindowClass;
typedef struct _ApplicationWindowPrivate ApplicationWindowPrivate;
#define _g_object_unref0(var) ((var == NULL) ? NULL : (var = (g_object_unref (var), NULL)))
#define _g_free0(var) (var = (g_free (var), NULL))

#define COMPONENTS_TYPE_LIST_VIEW (components_list_view_get_type ())
#define COMPONENTS_LIST_VIEW(obj) (G_TYPE_CHECK_INSTANCE_CAST ((obj), COMPONENTS_TYPE_LIST_VIEW, ComponentsListView))
#define COMPONENTS_LIST_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_CAST ((klass), COMPONENTS_TYPE_LIST_VIEW, ComponentsListViewClass))
#define COMPONENTS_IS_LIST_VIEW(obj) (G_TYPE_CHECK_INSTANCE_TYPE ((obj), COMPONENTS_TYPE_LIST_VIEW))
#define COMPONENTS_IS_LIST_VIEW_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), COMPONENTS_TYPE_LIST_VIEW))
#define COMPONENTS_LIST_VIEW_GET_CLASS(obj) (G_TYPE_INSTANCE_GET_CLASS ((obj), COMPONENTS_TYPE_LIST_VIEW, ComponentsListViewClass))

typedef struct _ComponentsListView ComponentsListView;
typedef struct _ComponentsListViewClass ComponentsListViewClass;

struct _ApplicationWindow {
	GtkWindow parent_instance;
	ApplicationWindowPrivate * priv;
};

struct _ApplicationWindowClass {
	GtkWindowClass parent_class;
};

struct _ApplicationWindowPrivate {
	GtkTextBuffer* text_buffer;
	char* filename;
};


static gpointer application_window_parent_class = NULL;

GType application_window_get_type (void) G_GNUC_CONST;
#define APPLICATION_WINDOW_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), TYPE_APPLICATION_WINDOW, ApplicationWindowPrivate))
enum  {
	APPLICATION_WINDOW_DUMMY_PROPERTY
};
ApplicationWindow* application_window_new (void);
ApplicationWindow* application_window_construct (GType object_type);
void application_window_run (ApplicationWindow* self);
static gint application_window_main (char** args, int args_length1);
static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self);
ComponentsListView* components_list_view_new (void);
ComponentsListView* components_list_view_construct (GType object_type);
GType components_list_view_get_type (void) G_GNUC_CONST;
static GObject * application_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties);
static void application_window_finalize (GObject* obj);



ApplicationWindow* application_window_construct (GType object_type) {
	ApplicationWindow * self;
	self = g_object_newv (object_type, 0, NULL);
	gtk_window_set_title ((GtkWindow*) self, "general-in-vala");
	return self;
}


ApplicationWindow* application_window_new (void) {
	return application_window_construct (TYPE_APPLICATION_WINDOW);
}


void application_window_run (ApplicationWindow* self) {
	g_return_if_fail (self != NULL);
	gtk_widget_show ((GtkWidget*) self);
	gtk_main ();
}


static gint application_window_main (char** args, int args_length1) {
	gint result = 0;
	ApplicationWindow* window;
	gtk_init (&args_length1, &args);
	window = g_object_ref_sink (application_window_new ());
	application_window_run (window);
	result = 0;
	_g_object_unref0 (window);
	return result;
}


int main (int argc, char ** argv) {
	g_type_init ();
	return application_window_main (argv, argc);
}


static void _gtk_main_quit_gtk_object_destroy (GtkObject* _sender, gpointer self) {
	gtk_main_quit ();
}


static GObject * application_window_constructor (GType type, guint n_construct_properties, GObjectConstructParam * construct_properties) {
	GObject * obj;
	GObjectClass * parent_class;
	ApplicationWindow * self;
	parent_class = G_OBJECT_CLASS (application_window_parent_class);
	obj = parent_class->constructor (type, n_construct_properties, construct_properties);
	self = APPLICATION_WINDOW (obj);
	{
		GtkVBox* vbox;
		GtkToolbar* toolbar;
		GtkScrolledWindow* scrolled_window;
		ComponentsListView* view;
		gtk_window_set_default_size ((GtkWindow*) self, 600, 400);
		g_signal_connect ((GtkObject*) self, "destroy", (GCallback) _gtk_main_quit_gtk_object_destroy, NULL);
		vbox = g_object_ref_sink ((GtkVBox*) gtk_vbox_new (FALSE, 0));
		gtk_container_add ((GtkContainer*) self, (GtkWidget*) vbox);
		gtk_widget_show ((GtkWidget*) vbox);
		toolbar = g_object_ref_sink ((GtkToolbar*) gtk_toolbar_new ());
		gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) toolbar, FALSE, FALSE, (guint) 0);
		gtk_widget_show ((GtkWidget*) toolbar);
		scrolled_window = g_object_ref_sink ((GtkScrolledWindow*) gtk_scrolled_window_new (NULL, NULL));
		gtk_box_pack_start ((GtkBox*) vbox, (GtkWidget*) scrolled_window, TRUE, TRUE, (guint) 0);
		g_object_set (scrolled_window, "hscrollbar-policy", GTK_POLICY_AUTOMATIC, NULL);
		g_object_set (scrolled_window, "vscrollbar-policy", GTK_POLICY_AUTOMATIC, NULL);
		gtk_widget_show ((GtkWidget*) scrolled_window);
		view = g_object_ref_sink (components_list_view_new ());
		gtk_container_add ((GtkContainer*) scrolled_window, (GtkWidget*) view);
		gtk_widget_show ((GtkWidget*) view);
		_g_object_unref0 (view);
		_g_object_unref0 (scrolled_window);
		_g_object_unref0 (toolbar);
		_g_object_unref0 (vbox);
	}
	return obj;
}


static void application_window_class_init (ApplicationWindowClass * klass) {
	application_window_parent_class = g_type_class_peek_parent (klass);
	g_type_class_add_private (klass, sizeof (ApplicationWindowPrivate));
	G_OBJECT_CLASS (klass)->constructor = application_window_constructor;
	G_OBJECT_CLASS (klass)->finalize = application_window_finalize;
}


static void application_window_instance_init (ApplicationWindow * self) {
	self->priv = APPLICATION_WINDOW_GET_PRIVATE (self);
}


static void application_window_finalize (GObject* obj) {
	ApplicationWindow * self;
	self = APPLICATION_WINDOW (obj);
	_g_object_unref0 (self->priv->text_buffer);
	_g_free0 (self->priv->filename);
	G_OBJECT_CLASS (application_window_parent_class)->finalize (obj);
}


GType application_window_get_type (void) {
	static volatile gsize application_window_type_id__volatile = 0;
	if (g_once_init_enter (&application_window_type_id__volatile)) {
		static const GTypeInfo g_define_type_info = { sizeof (ApplicationWindowClass), (GBaseInitFunc) NULL, (GBaseFinalizeFunc) NULL, (GClassInitFunc) application_window_class_init, (GClassFinalizeFunc) NULL, NULL, sizeof (ApplicationWindow), 0, (GInstanceInitFunc) application_window_instance_init, NULL };
		GType application_window_type_id;
		application_window_type_id = g_type_register_static (GTK_TYPE_WINDOW, "ApplicationWindow", &g_define_type_info, 0);
		g_once_init_leave (&application_window_type_id__volatile, application_window_type_id);
	}
	return application_window_type_id__volatile;
}




